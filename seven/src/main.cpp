#include <Arduino.h>
#include <NTPClient.h>
#include <WiFi.h> 
#include <WiFiUdp.h>
#include <ArduinoJson.h>  
#include <HTTPClient.h> 
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <string>
#include<cmath>
#include <U8g2lib.h>
#include <Wire.h>
#include <Ticker.h>
using namespace std;
U8G2_SSD1306_128X64_NONAME_F_HW_I2C  u8g2(U8G2_R0 , U8X8_PIN_NONE,22,21);
Ticker timer;//定时器

const char* ssid    = "Cinya"; 
const char* password = "yxylll..171";  
const char* host = "api.map.baidu.com";
WiFiClient client;
const int httpPort = 80;

string city,weather;
int temperature;
int currentHour,currentMinute,weekDay,monthDay,currentMonth,currentYear;//时间相关变量

double nowLatitude,nowLongitude,nowcompass;
string startLatitude,startLongitude,desLongitude,desLatitude;
bool startguide=false;
JsonObject result_of_getRoutes;
JsonObject result_of_getRoutes_0;
JsonObject getStep;
int direction=0;
int lastdirection=0;
int countNum=0;

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP,"ntp.aliyun.com");  //阿里云ntp服务器地址

BLEServer* pServer = NULL;
BLECharacteristic* pCharacteristic = NULL;

bool deviceConnected = false;
bool oldDeviceConnected = false;

//为服务和特征配uuid
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define ARDUINOJSON_USE_DOUBLE 1   //arduinojson存储double值

//获取ntp时间
void getNowTime()
{
  timeClient.update();
  unsigned long epochTime = timeClient.getEpochTime();
  //打印时间
  currentHour = timeClient.getHours();     
  Serial.print(currentHour);
  Serial.print(" : ");
  currentMinute = timeClient.getMinutes();
  if(currentMinute<10)
    Serial.print('0');
  Serial.print(currentMinute);
  Serial.print("  ");
  weekDay = timeClient.getDay();
  switch (weekDay)
  {
  case 1:
    Serial.print("Money  ");
    break;
  case 2:
    Serial.print("Tuesday  ");
    break;
  case 3:
    Serial.print("Wednesday  ");
    break;
  case 4:
    Serial.print("Thursday  ");
    break;
  case 5:
    Serial.print("Firday  ");
    break;
  case 6:
    Serial.print("Saturday  ");
    break;
  case 7:
    Serial.print("Sunday  ");
    break;
  default:
    break;
  }
  //将epochTime换算成年月日
  struct tm *ptm = gmtime ((time_t *)&epochTime);
  monthDay = ptm->tm_mday;
  currentMonth = ptm->tm_mon+1;
  currentYear=ptm->tm_year+1900;
  Serial.print(currentYear);
  Serial.print("-");
  Serial.print(currentMonth);
  Serial.print("-");
  Serial.println(monthDay);
}
//获取天气
void getWeather()
{
  if (!client.connect(host, httpPort))
  {
    Serial.println("connection failed"); 
    return;
  }

  String url ="/weather/v1/?district_id=610116&data_type=all&ak=oARO45C3e6ApRYbDNxdfrGW2DTwYmcDd";//610116是长安区的id

  client.print(String("GET ") + url + " HTTP/1.1\r\n" +
            "Host: " + host + "\r\n" +
            "Connection: close\r\n\r\n");
  delay(1500);
 
  String answer;
  while(client.available())
  {
    String line = client.readStringUntil('\r');
    answer += line;
  }
 
  client.stop();

  String jsonAnswer;
  int jsonIndex=0;
  
  for (int i = 0; i < answer.length(); i++) {
    if (answer[i] == '{') {
      jsonIndex = i;
      break;
    }
  }
  jsonAnswer = answer.substring(jsonIndex);
  Serial.println();
  // Stream& input;

  StaticJsonDocument<2048> doc;

  DeserializationError error = deserializeJson(doc, jsonAnswer);

  if (error) {
    Serial.print(F("deserializeJson() failed: "));
    Serial.println(error.f_str());
    return;
  }

  JsonObject result = doc["result"];

  JsonObject result_location = result["location"];
  const char* result_location_city = result_location["city"]; // "西安市" 

  JsonObject result_now = result["now"];
  const char* result_now_text = result_now["text"]; // "晴"
  int result_now_temp = result_now["temp"]; // 18

  city=result_location_city;
  weather=result_now_text;
  temperature=result_now_temp;
  Serial.print("city: ");
  Serial.println(city.c_str());
  Serial.print("weather: ");
  Serial.println(weather.c_str());
  Serial.print("temperature: ");
  Serial.println(temperature);
}

//获取路线
void getRoute(string slatitude,string slongitude,string dlatitude,string dlongitude)
{
  //处理一下string
  String plug1=slatitude.c_str(),plug2=slongitude.c_str(),plug3=dlatitude.c_str(),plug4=dlongitude.c_str();

  if (!client.connect(host, httpPort))
  {
    Serial.println("connection failed"); 
    return;
  }
  String url ="/directionlite/v1/walking?origin="+plug1+","+plug2+"&destination="+plug3+","+plug4+"&ak=oARO45C3e6ApRYbDNxdfrGW2DTwYmcDd&coord_type=gcj02&ret_coordtype=gcj02";
  
  client.print(String("GET ") + url + " HTTP/1.1\r\n" +
            "Host: " + host + "\r\n" +
            "Connection: close\r\n\r\n");
  delay(2000);
  
  String answer;
  while(client.available())
  {
    String line = client.readStringUntil('\r');
    answer += line;
  }
  
  client.stop();

  String jsonAnswer;
  int jsonIndex=0;
  
  for (int i = 0; i < answer.length(); i++) {
    if (answer[i] == '{') {
      jsonIndex = i;
      break;
    }
  }
  jsonAnswer = answer.substring(jsonIndex);
  Serial.println();
  // Stream& input;
  DynamicJsonDocument doc(22288);

  DeserializationError error = deserializeJson(doc, jsonAnswer);

  if (error) {
    Serial.print(F("deserializeJson() failed: "));
    Serial.println(error.f_str());
    return;
  }

  int status = doc["status"]; // 0
  //const char* message = doc["message"]; // "ok"
  Serial.print("status:");
  Serial.println(status);

  result_of_getRoutes = doc["result"];
  //总起点
  //double result_origin_lng = result["origin"]["lng"]; // 116.34592454655
  //double result_origin_lat = result["origin"]["lat"]; // 40.016807708536
  //总终点
  //double result_destination_lng = result["destination"]["lng"]; // 116.34916742944
  //double result_destination_lat = result["destination"]["lat"]; // 40.032050236156

  result_of_getRoutes_0 = result_of_getRoutes["routes"][0];   //路线方案集，百度给的大数组就一个元素
  //getStep = result_routes_0["steps"];
  startguide=true;

  
  //这个for(auto a：b)是c++11的新用法
  for (JsonObject result_routes_0_steps_item : result_of_getRoutes_0["steps"].as<JsonArray>()) {

    //int result_routes_0_steps_item_distance = result_routes_0_steps_item["distance"]; // 557, 47, 226, 802, ...  分段路线距离
    int result_routes_0_steps_item_direction = result_routes_0_steps_item["direction"]; // 0, 0, 0, 0, 9, 0, ...  进入道路的角度
    const char* result_routes_0_steps_item_instruction = result_routes_0_steps_item["instruction"];//路段描述：直行50米
    //const char* result_routes_0_steps_item_path = result_routes_0_steps_item["path"];

    //const char* result_routes_0_steps_item_start_location_lng = result_routes_0_steps_item["start_location"]["lng"];
    //const char* result_routes_0_steps_item_start_location_lat = result_routes_0_steps_item["start_location"]["lat"];

    const char* result_routes_0_steps_item_end_location_lng = result_routes_0_steps_item["end_location"]["lng"];
    const char* result_routes_0_steps_item_end_location_lat = result_routes_0_steps_item["end_location"]["lat"];
    double lng=atof(result_routes_0_steps_item_end_location_lng);
    double lag=atof(result_routes_0_steps_item_end_location_lat);
    Serial.print("分段经度：");
    Serial.println(lng,14);
    Serial.print("分段纬度：");
    Serial.println(lag,14);
    Serial.print("分段方向：");
    Serial.println(result_routes_0_steps_item_direction);
    Serial.println(result_routes_0_steps_item_instruction);
    Serial.println(" ");
  }
}

//蓝牙服务的回调函数
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
      Serial.println("现在有设备接入~");
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
      Serial.println("现在有设备断开连接~");
    };
};

//特征的回调函数
class myCharateristic:public BLECharacteristicCallbacks{
  void onWrite(BLECharacteristic* pCharacteristic){
      std::string receiveValue =pCharacteristic->getValue();
      Serial.println("");
      if(receiveValue.length()>0)
      {
        Serial.print("Received Value: ");
        if (receiveValue[0]=='d')
        {
          if(receiveValue[1]=='a')
          {
            desLatitude=receiveValue.erase(0,2);
            Serial.print("desLatitude:");
            Serial.println(desLatitude.c_str());
          }
          else if(receiveValue[1]=='g')
          {
            desLongitude=receiveValue.erase(0,2);
            Serial.print("desLongitude:");
            Serial.println(desLongitude.c_str());
          }
        }
        else if(receiveValue[0]=='s')
        {
          if(receiveValue[1]=='a')
          {
            startLatitude=receiveValue.erase(0,2);
            Serial.print("startLatitude:");
            Serial.println(startLatitude.c_str());
          }
          else if(receiveValue[1]=='g')
          {
            startLongitude=receiveValue.erase(0,2);
            Serial.print("startLongitude:");
            Serial.println(startLongitude.c_str());
          }
        }
        else if(receiveValue[0]=='c')
        {
          receiveValue=receiveValue.erase(0,1);
          nowcompass=atof(receiveValue.c_str());
          //Serial.print("nowcompass:");
          //Serial.println(nowcompass,14);
        }
        else if(receiveValue[0]=='n')
        {
          if(receiveValue[1]=='a')
          {
            receiveValue=receiveValue.erase(0,2);
            nowLatitude=atof(receiveValue.c_str());
            //Serial.print("nowLatitude:");
            //Serial.println(nowLatitude,14);
          }
          else if(receiveValue[1]=='g')
          {
            receiveValue=receiveValue.erase(0,2);
            nowLongitude=atof(receiveValue.c_str());
            //Serial.print("nowLongitude:");
            //Serial.println(nowLongitude,14);
          }
        }
        else if(receiveValue[0]=='g')
        {
          getRoute(startLatitude,startLongitude,desLatitude,desLongitude);
        }
      }
    }
};

//晴天
const unsigned char sunny[] U8X8_PROGMEM=
{0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0xE0,0x07,
0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,
0xE0,0x07,0x00,0x00,0x80,0x03,0xE0,0x03,0xC0,0x01,0xC0,0x07,0xC0,0x03,0xE0,0x03,
0xC0,0x0F,0x80,0x01,0xF0,0x03,0xC0,0x1F,0x00,0x00,0xF8,0x03,0x80,0x3F,0x00,0x00,
0xFC,0x01,0x00,0x3F,0xC0,0x03,0xFC,0x00,0x00,0x3E,0xF8,0x1F,0x7C,0x00,0x00,0x0C,
0xFE,0x7F,0x30,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x80,0xFF,0xFF,0x01,0x00,
0x00,0xC0,0xFF,0xFF,0x03,0x00,0x00,0xE0,0x1F,0xF8,0x07,0x00,0x00,0xE0,0x07,0xE0,
0x07,0x00,0x00,0xF0,0x03,0xC0,0x0F,0x00,0x00,0xF0,0x01,0x80,0x0F,0x00,0x3C,0xF0,
0x01,0x80,0x0F,0x3C,0xFF,0xF8,0x01,0x80,0x0F,0xFF,0xFF,0xF9,0x01,0x80,0x8F,0xFF,
0xFF,0xF9,0x01,0x80,0x8F,0xFF,0xFF,0xF8,0x01,0x80,0x0F,0xFF,0x3C,0xF0,0x01,0x80,
0x0F,0x3C,0x00,0xF0,0x01,0x80,0x0F,0x00,0x00,0xF0,0x03,0xC0,0x0F,0x00,0x00,0xE0,
0x07,0xE0,0x07,0x00,0x00,0xE0,0x1F,0xF8,0x07,0x00,0x00,0xC0,0xFF,0xFF,0x03,0x00,
0x00,0x80,0xFF,0xFF,0x01,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x0C,0xFE,0x7F,
0x30,0x00,0x00,0x3E,0xF8,0x1F,0x7C,0x00,0x00,0x3F,0x00,0x00,0xFC,0x00,0x80,0x3F,
0x00,0x00,0xFC,0x01,0xC0,0x1F,0x00,0x00,0xF8,0x03,0xC0,0x0F,0x80,0x01,0xF0,0x03,
0xC0,0x07,0xC0,0x03,0xE0,0x03,0x80,0x03,0xE0,0x07,0xC0,0x01,0x00,0x00,0xE0,0x07,
0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,
0xE0,0x07,0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00};

//阴天
const unsigned char cloudy[] U8X8_PROGMEM=
{0x00,0xF0,0x3F,0x00,0x00,0x00,0x00,0xF8,0xFF,0x00,0x00,0x00,0x00,0xFE,0xFF,0x03,
0x00,0x00,0x00,0xFF,0xFF,0x07,0x00,0x00,0x80,0xFF,0xFF,0x0F,0x00,0x00,0xC0,0xFF,
0xFF,0x1F,0x00,0x00,0xE0,0xFF,0xFF,0x3F,0x00,0x00,0xF0,0x1F,0xC0,0x7F,0x00,0x00,
0xF0,0x0F,0x80,0xFF,0x00,0x00,0xF8,0x07,0x00,0xFF,0x00,0x00,0xFC,0x03,0x00,0xFE,
0x01,0x00,0xFC,0x01,0x00,0xFC,0x1D,0x00,0xFC,0x00,0x00,0xF8,0xFF,0x00,0xFE,0x00,
0x00,0xF8,0xFF,0x01,0x7E,0x00,0x00,0xF0,0xFF,0x03,0x7F,0x00,0x00,0xF0,0xFF,0x07,
0x3F,0x00,0x00,0xE0,0xFF,0x0F,0x3F,0x00,0x00,0xE0,0xFF,0x1F,0x3F,0x00,0x00,0xE0,
0xF3,0x3F,0x3F,0x00,0x00,0xE0,0xC0,0x3F,0x3F,0x00,0x00,0x00,0x00,0x7F,0x1F,0x00,
0x00,0x00,0x00,0x7F,0x1F,0x00,0x00,0x00,0x00,0xFE,0x1F,0x00,0x00,0x00,0x00,0xFC,
0x1F,0x00,0x00,0x00,0x00,0xFC,0x1F,0x00,0x00,0x00,0x00,0xFC,0x1F,0x00,0x00,0x00,
0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0xF8,0x3F,0x00,
0x00,0x00,0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0xF8,0x3F,0x00,0x00,0x00,0x00,0xF8,
0x7F,0x00,0x00,0x00,0x00,0xF8,0x7E,0x00,0x00,0x00,0x00,0xFC,0xFE,0x00,0x00,0x00,
0x00,0xFC,0xFC,0x00,0x00,0x00,0x00,0xFC,0xFC,0x01,0x00,0x00,0x00,0xFC,0xFC,0x03,
0x00,0x00,0x00,0xFE,0xF8,0x07,0x00,0x00,0x00,0x7F,0xF0,0x0F,0x00,0x00,0x80,0x7F,
0xF0,0x1F,0x00,0x00,0xC0,0x3F,0xE0,0xFF,0xFF,0xFF,0xFF,0x3F,0xC0,0xFF,0xFF,0xFF,
0xFF,0x1F,0x80,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0xFF,0xFF,0xFF,0xFF,0x07,0x00,0xFE,
0xFF,0xFF,0xFF,0x03,0x00,0xF8,0xFF,0xFF,0xFF,0x01,0x00,0xE0,0xFF,0xFF,0x7F,0x00};

//雨天
const unsigned char rainy[] U8X8_PROGMEM=
{0x00,0xF0,0xFF,0x00,0x00,0x00,0x00,0xFE,0xFF,0x03,0x00,0x00,0x00,0xFF,0xFF,0x07,
0x00,0x00,0xC0,0xFF,0xFF,0x1F,0x00,0x00,0xE0,0xFF,0xFF,0x3F,0x00,0x00,0xF0,0x7F,
0xE0,0x7F,0x00,0x00,0xF8,0x0F,0x00,0xFF,0x00,0x00,0xF8,0x03,0x00,0xFE,0x00,0x00,
0xFC,0x01,0x00,0xFC,0x1F,0x00,0xFC,0x00,0x00,0xF8,0xFF,0x01,0x7E,0x00,0x00,0xF0,
0xFF,0x03,0x3E,0x00,0x00,0xE0,0xFF,0x0F,0x3F,0x00,0x00,0xE0,0xFF,0x1F,0x3F,0x00,
0x00,0xE0,0xFF,0x3F,0x1F,0x00,0x00,0xE0,0xC0,0x3F,0x1F,0x00,0x00,0x00,0x00,0x7F,
0x1F,0x00,0x00,0x00,0x00,0xFE,0x1F,0x00,0x00,0x00,0x00,0xFC,0x1F,0x00,0x00,0x00,
0x00,0xF8,0x1F,0x00,0x00,0x00,0x00,0xF8,0x1F,0x00,0x00,0x00,0x00,0xF8,0x3F,0x80,
0x00,0x00,0x01,0xF8,0x3F,0xE0,0x03,0x80,0x07,0xF8,0x3F,0xE0,0x03,0xC0,0x0F,0xF8,
0x7E,0xE0,0x03,0xC0,0x0F,0xF8,0xFE,0xE0,0x03,0xC0,0x0F,0xFC,0xFC,0xE1,0xC3,0xC3,
0x0F,0xFC,0xF8,0xE1,0xC3,0xC7,0x0F,0xFE,0xF8,0xE1,0xE3,0xC7,0x0F,0x7F,0xF0,0xE1,
0xE3,0xC7,0x8F,0x3F,0xE0,0xE1,0xE3,0xC7,0x8F,0x1F,0xC0,0xE3,0xE3,0xC7,0x8F,0x1F,
0x80,0xE3,0xE3,0xC7,0x8F,0x07,0x00,0xE0,0xE3,0xC7,0x8F,0x03,0x00,0xE0,0xE3,0xC7,
0x8F,0x01,0x00,0xE0,0xE3,0xC7,0x0F,0x00,0x00,0xE0,0xE3,0xC7,0x0F,0x00,0x00,0xE0,
0xE3,0xC7,0x0F,0x00,0x00,0xE0,0xE3,0xC7,0x0F,0x00,0x00,0xE0,0xE3,0xC7,0x0F,0x00,
0x00,0xE0,0xE3,0xC7,0x0F,0x00,0x00,0xE0,0xE3,0xC7,0x0F,0x00,0x00,0xE0,0xE3,0xC7,
0x0F,0x00,0x00,0xC0,0xE1,0x87,0x07,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,
0xE0,0x07,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00};

//右转
const unsigned char TurnRight[] U8X8_PROGMEM=
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x3F,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x03,0x00,
0x00,0x00,0x00,0x00,0xFE,0xFF,0x07,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x03,0x00,
0x00,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x3F,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0xFE,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

//左转
const unsigned char TurnLeft[] U8X8_PROGMEM=
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xC0,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xF0,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0xC0,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xC0,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x80,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xF8,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xF0,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0xC0,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};

//直行
const unsigned char GoStraight[] U8X8_PROGMEM=
{0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x00,0x00,
0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x1F,0x00,0x00,0x00,
0x00,0x00,0x00,0xFC,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x7F,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x01,0x00,0x00,
0x00,0x00,0xC0,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0xC0,0xFF,0xFF,0x03,0x00,0x00,
0x00,0x00,0xE0,0xFF,0xFF,0x07,0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0x0F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0x3F,0x00,0x00,
0x00,0x00,0xFE,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0xFE,0xFF,0xFF,0x7F,0x00,0x00,
0x00,0x80,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x00,0xC0,0xFF,0xFF,0xFF,0xFF,0x03,0x00,
0x00,0xC0,0xFF,0xFF,0xFF,0xFF,0x03,0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,
0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0x3F,0x00,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x01,
0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,
0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,
0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,
0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00,0x00,0x00,0xF8,0xFF,0xFF,0x1F,0x00,0x00};

  // 初始化OLED显示屏
void oledSetup() {
  u8g2.begin();
  u8g2.enableUTF8Print();
  u8g2.setFont(u8g2_font_wqy12_t_gb2312a);
  u8g2.setFontPosTop();
  u8g2.clearDisplay();
}
//在OLED上显示天气
void displayWeatherAndTime()
{
  u8g2.clearBuffer();           // 清空显示设备内部缓冲区
  u8g2.setDisplayRotation(U8G2_MIRROR);//镜像翻转
  if(weather=="晴")
    u8g2.drawXBMP( 0 , 4 , 48 , 48 , sunny ); 
  else if(weather=="阴"||weather=="多云")
    u8g2.drawXBMP(0,4,48,48,cloudy);
  else if(weather=="小雨"||weather=="中雨"||weather=="大雨")
    u8g2.drawXBMP(0,5,48,48,rainy);
  u8g2.setCursor(12, 52);
  u8g2.print(currentMonth);
  u8g2.print('-');
  u8g2.print(monthDay);
  u8g2.setCursor(52, 7);
  u8g2.print("城市:");
  u8g2.print(city.c_str());
  u8g2.setCursor(52,22 );
  u8g2.print("温度:");
  u8g2.print(temperature);
  u8g2.print("℃");
  u8g2.setCursor(75,39);
  u8g2.print(currentHour);
  u8g2.print(':');
  if(currentMinute<10)
    u8g2.print('0');
  u8g2.print(currentMinute);
  switch (weekDay)
  {
    case 1:
      u8g2.drawStr(55,52,"Money");
      break;
    case 2:
      u8g2.drawStr(55,52,"Tuesday");
      break;
    case 3:
      u8g2.drawStr(55,52,"Wednesday");
      break;
    case 4:
      u8g2.drawStr(55,52,"Thursday");
      break;
    case 5:
      u8g2.drawStr(55,52,"Firday");
      break;
    case 6:
      u8g2.drawStr(55,52,"Saturday");
      break;
    case 7:
      u8g2.drawStr(55,52,"Sunday");
      break;
    default:
      //u8g2.drawStr(55,52,"Sunday");
      break;
  }
  u8g2.sendBuffer();         // 显示缓冲区内容
}

//oled显示路线 1右转 2左转 3直行 4到达目的地
void displayPath(int key)
{
  u8g2.clearBuffer();           // 清空显示设备内部缓冲区
  u8g2.setDisplayRotation(U8G2_MIRROR);//镜像翻转
  switch (key)
  {
  case 1:
    u8g2.drawXBMP( 32 , 0 , 64 , 64 , TurnRight );
    break;
  case 2:
    u8g2.drawXBMP( 32 , 0 , 64 , 64 , TurnLeft);
    break;
  case 3:
    u8g2.drawXBMP( 32 , 0 , 64 , 64 , GoStraight);
    break;
  case 4:
    u8g2.setCursor(15, 25);
    u8g2.print("您已到达目的地");
    break;
  default:
    break;
  }
  u8g2.sendBuffer();         // 显示缓冲区内容
  //delay(1000);  
}


void setup() {
  Serial.begin(115200);
  oledSetup();
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected"); 
  Serial.print("IP address: ");   
  Serial.println(WiFi.localIP());

  timeClient.begin();
  timeClient.setTimeOffset(28800);  //北京时间（东八区）   + 1区 偏移3600（s）， +8区 ：3600×8 = 28800

  getWeather();
  BLEDevice::init("ESP32");     //创建蓝牙设备和名称
  pServer = BLEDevice::createServer();      //创建服务器
  pServer->setCallbacks(new MyServerCallbacks());   //绑定服务的回调函数
  BLEService *pService = pServer->createService(SERVICE_UUID);    //创建服务
  //创建特征值
  pCharacteristic = pService->createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ   |
                      BLECharacteristic::PROPERTY_WRITE  |
                      BLECharacteristic::PROPERTY_NOTIFY 
                    );
  pCharacteristic->setCallbacks(new myCharateristic());    //绑定特征的回调函数
  pCharacteristic->addDescriptor(new BLE2902());
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(false);
  pAdvertising->setMinPreferred(0x00); 
  BLEDevice::startAdvertising();   //开始广播
}

void loop() {
  //如果断开了连接就重新广播
  if (!deviceConnected && oldDeviceConnected) {
      delay(500); 
      pServer->startAdvertising(); // restart advertising
      Serial.println("start advertising");
      oldDeviceConnected = deviceConnected;
  }
  // connecting
  if (deviceConnected && !oldDeviceConnected) {
      oldDeviceConnected = deviceConnected;
  }
  if(!startguide)
  {
    //不导航就显示时间和时间
    getNowTime();
    displayWeatherAndTime();
    delay(1000);
  }
  else{
    //delay(1000);
    //开始导航  1右转 2左转 3直行 4到达目的地
    for(JsonObject guideroutes : result_of_getRoutes_0["steps"].as<JsonArray>())
    {
      countNum++;
      direction= guideroutes["direction"]; 
      //const char* routes_start_lng = guideroutes["start_location"]["lng"];
      //const char* routes_start_lat = guideroutes["start_location"]["lat"];
      const char* routes_end_lng = guideroutes["end_location"]["lng"];
      const char* routes_end_lat = guideroutes["end_location"]["lat"];
      //double start_lng=atof(routes_start_lng);
      //double start_lat=atof(routes_start_lat);
      double end_lng=atof(routes_end_lng);
      double end_lat=atof(routes_end_lat);
      //Serial.print("方向：");
      //Serial.println(direction);
      //Serial.println(start_lng,14);
      //Serial.println(start_lat,14);
      //Serial.print("此段路的终点的经度：");
      //Serial.println(end_lng,14);
      //Serial.print("此段路的终点的纬度：");
      //Serial.println(end_lat,14);
      //Serial.println("");
      if(countNum>1)
      {
        if(direction-lastdirection<0 && direction-lastdirection>-5)
        {
          while(fabs(nowLatitude-end_lat)<0.0001 && fabs(nowLongitude-end_lng)<0.0001)
          {
            Serial.println("左转");
            displayPath(2);
            delay(300);
          }
        }
        else if(direction-lastdirection>0 && direction-lastdirection<5)
        {
          while(fabs(nowLatitude-end_lat)<0.0001 && fabs(nowLongitude-end_lng)<0.0001)
          {
            Serial.println("右转");
            displayPath(1);
            delay(300);
          }
        }
      }

      while(true)
      {
        Serial.println("直行");
        displayPath(3);
        delay(300);
        //修正方向
        if(nowcompass-30*direction>90)
        {
          Serial.println("左转");
        }
        else if(nowcompass-30*direction<-90)
        {
          Serial.println("右转");
        }
        //到达转折点
        Serial.print("经度差");
        Serial.println(fabs(nowLatitude-end_lat),14);
        Serial.println(fabs(nowLatitude-end_lat)<0.0001);
        Serial.print("纬度差");
        Serial.println(fabs(nowLongitude-end_lng),14);
        Serial.println(fabs(nowLongitude-end_lng)<0.0001);
        if((fabs(nowLatitude-end_lat)<0.0001) && (fabs(nowLongitude-end_lng)<0.0001))
        {
          Serial.println("到达转折点");
          break;
        }
      }
      lastdirection=direction;
    }
    Serial.println("到达目的地！");
    displayPath(4);
    delay(10000);
    startguide=false;
  }
}
